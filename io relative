

IO 流、文件操作相关

一、
1、  io.parseFile
import java.io.BufferedReader;      
import java.io.FileNotFoundException;      
import java.io.FileReader;      
import java.io.IOException;      
import java.util.Vector;      
     
public class CsvParse {      
    //声明读取流      
    private BufferedReader inStream = null;      
    //声明返回向量      
    private Vector<String> vContent = null;      
     
    /**  
     * 构建方法，参数为csv文件名<br>    
     * 如果没有找到文件，则抛出异常<br>    
     * 如果抛出异常，则不能进行页面的文件读取操作    
     */     
    public CsvParse(String csvFileName) throws FileNotFoundException {      
        inStream = new BufferedReader(new FileReader(csvFileName));      
    }      
     
    /**  
     * 返回已经读取到的一行的向量    
     * @return vContent    
     */     
    public Vector<String> getVContent() {      
        return this.vContent;      
    }      
     
    /**  
     * 读取下一行，并把该行的内容填充入向量中<br>    
     * 返回该向量<br>    
     * @return vContent 装载了下一行的向量    
     * @throws IOException    
     * @throws Exception    
     */     
    public Vector<String> getLineContentVector() throws IOException, Exception {      
        if (this.readCSVNextRecord()) {      
            return this.vContent;      
        }      
        return null;      
    }      
     
    /**  
     * 关闭流    
     */     
    public void close() {      
        if (inStream != null) {      
            try {      
                inStream.close();      
            } catch (IOException e) {      
                // TODO Auto-generated catch block      
                e.printStackTrace();      
            }      
        }      
    }      
     
    /**  
     * 调用此方法时应该确认该类已经被正常初始化<br>    
     * 该方法用于读取csv文件的下一个逻辑行<br>    
     * 读取到的内容放入向量中<br>    
     * 如果该方法返回了false，则可能是流未被成功初始化<br>    
     * 或者已经读到了文件末尾<br>    
     * 如果发生异常，则不应该再进行读取    
     * @return 返回值用于标识是否读到文件末尾    
     * @throws Exception    
     */     
    public boolean readCSVNextRecord() throws IOException, Exception {      
        //如果流未被初始化则返回false      
        if (inStream == null) {      
            return false;      
        }      
        //如果结果向量未被初始化，则初始化      
        if (vContent == null) {      
            vContent = new Vector<String>();      
        }      
        //移除向量中以前的元素      
        vContent.removeAllElements();      
        //声明逻辑行      
        String logicLineStr = "";      
        //用于存放读到的行      
        StringBuilder strb = new StringBuilder();      
        //声明是否为逻辑行的标志，初始化为false      
        boolean isLogicLine = false;      
        try {      
            while (!isLogicLine) {      
                String newLineStr = inStream.readLine();      
                if (newLineStr == null) {      
                    strb = null;      
                    vContent = null;      
                    isLogicLine = true;      
                    break;      
                }      
                if (newLineStr.startsWith("#")) {      
                    // 去掉注释      
                    continue;      
                }      
                if (!strb.toString().equals("")) {      
                    strb.append("/r/n");      
                }      
                strb.append(newLineStr);      
                String oldLineStr = strb.toString();      
                if (oldLineStr.indexOf(",") == -1) {      
                    // 如果该行未包含逗号      
                    if (containsNumber(oldLineStr, "\"") % 2 == 0) {      
                        // 如果包含偶数个引号      
                        isLogicLine = true;      
                        break;      
                    } else {      
                        if (oldLineStr.startsWith("\"")) {      
                            if (oldLineStr.equals("\"")) {      
                                continue;      
                            } else {      
                                String tempOldStr = oldLineStr.substring(1);      
                                if (isQuoteAdjacent(tempOldStr)) {      
                                    // 如果剩下的引号两两相邻，则不是一行      
                                    continue;      
                                } else {      
                                    // 否则就是一行      
                                    isLogicLine = true;      
                                    break;      
                                }      
                            }      
                        }      
                    }      
                } else {      
                    // quotes表示复数的quote      
                    String tempOldLineStr = oldLineStr.replace("\"\"", "");      
                    int lastQuoteIndex = tempOldLineStr.lastIndexOf("\"");      
                    if (lastQuoteIndex == 0) {      
                        continue;      
                    } else if (lastQuoteIndex == -1) {      
                        isLogicLine = true;      
                        break;      
                    } else {      
                        tempOldLineStr = tempOldLineStr.replace("\",\"", "");      
                        lastQuoteIndex = tempOldLineStr.lastIndexOf("\"");      
                        if (lastQuoteIndex == 0) {      
                            continue;      
                        }      
                        if (tempOldLineStr.charAt(lastQuoteIndex - 1) == ',') {      
                            continue;      
                        } else {      
                            isLogicLine = true;      
                            break;      
                        }      
                    }      
                }      
            }      
        } catch (IOException ioe) {      
            ioe.printStackTrace();      
            //发生异常时关闭流      
            if (inStream != null) {      
                inStream.close();      
            }      
            throw ioe;      
        } catch (Exception e) {      
            e.printStackTrace();      
            //发生异常时关闭流      
            if (inStream != null) {      
                inStream.close();      
            }      
            throw e;      
        }      
        if (strb == null) {      
            // 读到行尾时为返回      
            return false;      
        }      
        //提取逻辑行      
        logicLineStr = strb.toString();      
        if (logicLineStr != null) {      
            //拆分逻辑行，把分离出来的原子字符串放入向量中      
            while (!logicLineStr.equals("")) {      
                String[] ret = readAtomString(logicLineStr);      
                String atomString = ret[0];      
                logicLineStr = ret[1];      
                vContent.add(atomString);      
            }      
        }      
        return true;      
    }
    
     
    /**  
     * 读取一个逻辑行中的第一个字符串，并返回剩下的字符串<br>    
     * 剩下的字符串中不包含第一个字符串后面的逗号<br>    
     * @param lineStr 一个逻辑行    
     * @return 第一个字符串和剩下的逻辑行内容    
     */     
    public String[] readAtomString(String lineStr) {      
        String atomString = "";//要读取的原子字符串      
        String orgString = "";//保存第一次读取下一个逗号时的未经任何处理的字符串      
        String[] ret = new String[2];//要返回到外面的数组      
        boolean isAtom = false;//是否是原子字符串的标志      
        String[] commaStr = lineStr.split(",");      
        while (!isAtom) {      
            for (String str : commaStr) {      
                if (!atomString.equals("")) {      
                    atomString = atomString + ",";      
                }      
                atomString = atomString + str;      
                orgString = atomString;      
                if (!isQuoteContained(atomString)) {      
                    // 如果字符串中不包含引号，则为正常，返回      
                    isAtom = true;      
                    break;      
                } else {      
                    if (!atomString.startsWith("\"")) {      
                        // 如果字符串不是以引号开始，则表示不转义，返回      
                        isAtom = true;      
                        break;      
                    } else if (atomString.startsWith("\"")) {      
                        // 如果字符串以引号开始，则表示转义      
                        if (containsNumber(atomString, "\"") % 2 == 0) {      
                            // 如果含有偶数个引号      
                            String temp = atomString;      
                            if (temp.endsWith("\"")) {      
                                temp = temp.replace("\"\"", "");      
                                if (temp.equals("")) {      
                                    // 如果temp为空      
                                    atomString = "";      
                                    isAtom = true;      
                                    break;      
                                } else {      
                                    // 如果temp不为空，则去掉前后引号      
                                    temp = temp.substring(1, temp      
                                            .lastIndexOf("\""));      
                                    if (temp.indexOf("\"") > -1) {      
                                        // 去掉前后引号和相邻引号之后，若temp还包含有引号      
                                        // 说明这些引号是单个单个出现的      
                                        temp = atomString;      
                                        temp = temp.substring(1);      
                                        temp = temp.substring(0, temp      
                                                .indexOf("\""))      
                                                + temp.substring(temp      
                                                        .indexOf("\"") + 1);      
                                        atomString = temp;      
                                        isAtom = true;      
                                        break;      
                                    } else {      
                                        // 正常的csv文件      
                                        temp = atomString;      
                                        temp = temp.substring(1, temp      
                                                .lastIndexOf("\""));      
                                        temp = temp.replace("\"\"", "\"");      
                                        atomString = temp;      
                                        isAtom = true;      
                                        break;      
                                    }      
                                }      
                            } else {      
                                // 如果不是以引号结束，则去掉前两个引号      
                                temp = temp.substring(1, temp.indexOf("\"", 1))   
                                        + temp     
                                                .substring(temp     
                                                        .indexOf("\"", 1) + 1);     
                                atomString = temp;     
                                isAtom = true;     
                                break;     
                            }     
                        } else {     
                            // 如果含有奇数个引号     
                            // TODO 处理奇数个引号的情况     
                            if (!atomString.equals("\"")) {      
                                String tempAtomStr = atomString.substring(1);      
                                if (!isQuoteAdjacent(tempAtomStr)) {      
                                    // 这里做的原因是，如果判断前面的字符串不是原子字符串的时候就读取第一个取到的字符串      
                                    // 后面取到的字符串不计入该原子字符串      
                                    tempAtomStr = atomString.substring(1);      
                                    int tempQutoIndex = tempAtomStr      
                                            .indexOf("\"");      
                                    // 这里既然有奇数个quto，所以第二个quto肯定不是最后一个      
                                    tempAtomStr = tempAtomStr.substring(0,      
                                            tempQutoIndex)      
                                            + tempAtomStr      
                                                    .substring(tempQutoIndex + 1);      
                                    atomString = tempAtomStr;      
                                    isAtom = true;      
                                    break;      
                                }      
                            }      
                        }      
                    }      
                }      
            }      
        }      
        //先去掉之前读取的原字符串的母字符串      
        if (lineStr.length() > orgString.length()) {      
            lineStr = lineStr.substring(orgString.length());      
        } else {      
            lineStr = "";      
        }      
        //去掉之后，判断是否以逗号开始，如果以逗号开始则去掉逗号      
        if (lineStr.startsWith(",")) {      
            if (lineStr.length() > 1) {      
                lineStr = lineStr.substring(1);      
            } else {      
                lineStr = "";      
            }      
        }      
        ret[0] = atomString;      
        ret[1] = lineStr;      
        return ret;      
    }      
     
    /**  
     * 该方法取得父字符串中包含指定字符串的数量<br>    
     * 如果父字符串和字字符串任意一个为空值，则返回零    
     * @param parentStr    
     * @param parameter    
     * @return    
     */     
    public int containsNumber(String parentStr, String parameter) {      
        int containNumber = 0;      
        if (parentStr == null || parentStr.equals("")) {      
            return 0;      
        }      
        if (parameter == null || parameter.equals("")) {      
            return 0;      
        }      
        for (int i = 0; i < parentStr.length(); i++) {      
            i = parentStr.indexOf(parameter, i);      
            if (i > -1) {      
                i = i + parameter.length();      
                i--;   //??? i- 什么意思？   
                containNumber = containNumber + 1;      
            } else {      
                break;      
            }      
        }      
        return containNumber;      
    }      
     
    /**  
     * 该方法用于判断给定的字符串中的引号是否相邻<br>    
     * 如果相邻返回真，否则返回假<br>    
     *    
     * @param p_String    
     * @return    
     */     
    public boolean isQuoteAdjacent(String p_String) {      
        boolean ret = false;      
        String temp = p_String;      
        temp = temp.replace("\"\"", "");      
        if (temp.indexOf("\"") == -1) {      
            ret = true;      
        }      
        // TODO 引号相邻      
        return ret;      
    }      
     
    /**  
     * 该方法用于判断给定的字符串中是否包含引号<br>    
     * 如果字符串为空或者不包含返回假，包含返回真<br>    
     *    
     * @param p_String    
     * @return    
     */     
    public boolean isQuoteContained(String p_String) {      
        boolean ret = false;      
        if (p_String == null || p_String.equals("")) {      
            return false;      
        }      
        if (p_String.indexOf("\"") > -1) {      
            ret = true;      
        }      
        return ret;      
    }      
     
    /**  
     * 读取文件标题    
     *    
     * @return 正确读取文件标题时返回 true,否则返回 false    
     * @throws Exception    
     * @throws IOException    
     */     
    public boolean readCSVFileTitle() throws IOException, Exception {      
        String strValue = "";      
        boolean isLineEmpty = true;      
        do {      
            if (!readCSVNextRecord()) {      
                return false;      
            }      
            if (vContent.size() > 0) {      
                strValue = (String) vContent.get(0);      
            }      
            for (String str : vContent) {      
                if (str != null && !str.equals("")) {      
                    isLineEmpty = false;      
                    break;      
                }      
            }      
            // csv 文件中前面几行以 # 开头为注释行      
        } while (strValue.trim().startsWith("#") || isLineEmpty);      
        return true;      
    }      
} 

2、
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class ParseExcelDemo {

	public static void main(String[] args) {

		 Workbook wb =null;
	        Sheet sheet = null;
	        Row row = null;
	        List<Map<String,String>> list = null;
	        String cellData = null;
	        String filePath = "D:\\junz\\task\\5G\\file\\2D覆盖预测传模\\PropagationModel\\Rayce HW\\Rayce HW(Default).xls";
//	        String columns[] = {"name","age","score"};
	        wb = readExcel(filePath);
	        if(wb != null){
	            //用来存放表中数据
	            list = new ArrayList<Map<String,String>>();
	            //获取第一个sheet
	            sheet = wb.getSheetAt(0);
	            //获取最大行数
	            int rownum = sheet.getPhysicalNumberOfRows();
	            System.out.println("rownums: " + rownum);
	            //获取第一行
	            row = sheet.getRow(0);
	            //获取最大列数
	            int colnum = row.getPhysicalNumberOfCells();
	            System.out.println("colnums: " + colnum);
	            int k = 1;
	            for (int i = 0; i<rownum; i++) {
	                Map<String,String> map = new LinkedHashMap<String,String>();
	                row = sheet.getRow(i);
	                if(row !=null){
	                    for (int j=0; j<colnum; j++){
	                        cellData = (String) getCellFormatValue(row.getCell(j));
//	                        System.out.println(cellData);
	                        map.put(String.valueOf(k++), cellData);
	                    }
	                }else{
	                    break;
	                }
	                list.add(map);
//	                System.out.println(list.size());
	            }
	        }
	        //遍历解析出来的list
	        for (Map<String,String> map : list) {
	            for (Entry<String,String> entry : map.entrySet()) {
	                System.out.println(entry.getKey()+":"+entry.getValue()+",");
	            }
	            System.out.println();
	        }
		
	}
	
	//读取excel
    public static Workbook readExcel(String filePath){
        Workbook wb = null;
        if(filePath==null){
            return null;
        }
        String extString = filePath.substring(filePath.lastIndexOf("."));
        InputStream is = null;
        try {
            is = new FileInputStream(filePath);
            if(".xls".equals(extString)){
                return wb = new HSSFWorkbook(is);
            }else if(".xlsx".equals(extString)){
                return wb = new XSSFWorkbook(is);
            }else{
                return wb = null;
            }
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return wb;
    }
    public static Object getCellFormatValue(Cell cell){
        Object cellValue = null;
        if(cell!=null){
            //判断cell类型
            switch(cell.getCellType()){
            case Cell.CELL_TYPE_NUMERIC:{
                cellValue = String.valueOf(cell.getNumericCellValue());
                break;
            }
            case Cell.CELL_TYPE_BOOLEAN:{
            	
            }
            case Cell.CELL_TYPE_FORMULA:{
                //判断cell是否为日期格式
                if(DateUtil.isCellDateFormatted(cell)){
                    //转换为日期格式YYYY-mm-dd
                    cellValue = cell.getDateCellValue();
                }else{
                    //数字
                    cellValue = String.valueOf(cell.getNumericCellValue());
                }
                break;
            }
            case Cell.CELL_TYPE_STRING:{
                cellValue = cell.getRichStringCellValue().getString();
//                cellValue = cell.getStringCellValue();
                break;
            }
            default:
                cellValue = "";
            }
        }else{
            cellValue = "";
        }
        return cellValue;
    }

}

---io.util
3、
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.attribute.AclEntry;
import java.nio.file.attribute.AclEntryFlag;
import java.nio.file.attribute.AclEntryPermission;
import java.nio.file.attribute.AclEntryType;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.nio.file.attribute.UserPrincipal;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;


public class FileAttributeUtility {

	private static final Logger LOG = Logger.getLogger(FileAttributeUtility.class);

	private static final boolean isPosix = FileSystems.getDefault()
			.supportedFileAttributeViews().contains("posix");

	public static FileAttribute<?> getDefaultFileAttribute(File file) {
		Path path = file.toPath();

		// File permissions should be such that only user may read/write file
		FileAttribute<?> fa = null;
		if (isPosix) {
			Set<PosixFilePermission> perms = PosixFilePermissions
					.fromString("rw-------");
			FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions
					.asFileAttribute(perms);
			fa = attr;
		} else {
			// for not posix must support ACL, or failed.
			String userName = System.getProperty("user.name");
			UserPrincipal user = null;
			try {
				user = path.getFileSystem().getUserPrincipalLookupService()
						.lookupPrincipalByName(userName);
			} catch (IOException e) {
				LOG.error("#getDefaultFileAttribute IOException", e);
			}
			AclEntryPermission[] permList = new AclEntryPermission[] {
					AclEntryPermission.READ_DATA,
					AclEntryPermission.READ_ATTRIBUTES,
					AclEntryPermission.READ_NAMED_ATTRS,
					AclEntryPermission.READ_ACL, AclEntryPermission.WRITE_DATA,
					AclEntryPermission.DELETE, AclEntryPermission.APPEND_DATA,
					AclEntryPermission.WRITE_ATTRIBUTES,
					AclEntryPermission.WRITE_NAMED_ATTRS,
					AclEntryPermission.WRITE_ACL,
					AclEntryPermission.SYNCHRONIZE };
			Set<AclEntryPermission> perms = EnumSet
					.noneOf(AclEntryPermission.class);
			for (AclEntryPermission perm : permList)
				perms.add(perm);

			final AclEntry entry = AclEntry
					.newBuilder()
					.setType(AclEntryType.ALLOW)
					.setPrincipal(user)
					.setPermissions(perms)
					.setFlags(
							new AclEntryFlag[] { AclEntryFlag.FILE_INHERIT,
									AclEntryFlag.DIRECTORY_INHERIT }).build();

			FileAttribute<List<AclEntry>> aclattrs = null;
			aclattrs = new FileAttribute<List<AclEntry>>() {
				public String name() {
					return "acl:acl";
				} /* Windows ACL */

				public List<AclEntry> value() {
					ArrayList<AclEntry> l = new ArrayList<AclEntry>();
					l.add(entry);
					return l;
				}
			};
			fa = aclattrs;
		}

		return fa;
	}
}

4、
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.apache.poi.xssf.usermodel.XSSFCell;


public class FileUtil {

	public final static Logger LOG = Logger.getLogger(FileUtil.class);
	
//	File ff = new File("");
	
	
	/**
	 * 解析xml
	 * List<ArrayList<String>> 规则：
	 * 1： 传模/地物标识字段 + 列头字段
	 * 2： 传模/地物标识字段 + 对于列头参数内容
	 * 
	 * @return List<ArrayList<String>> 
	 */
	@SuppressWarnings({ "deprecation" })
	public static List<ArrayList<String>> parseExcel(InputStream is) {
		LOG.info("#nre2e#parseExcel#Start#");
		List<ArrayList<String>> retlList = new ArrayList<ArrayList<String>>();
		//1-读取文件
//		FileInputStream fis = null;
	    try { 
//	    	try(FileInputStream fis = new FileInputStream(file)) { 
	        Workbook workbook = WorkbookFactory.create(is);   
	        //遍历Sheet
            int sheetNum = workbook.getNumberOfSheets();
            System.out.println(sheetNum);
            for(int k=0; k<sheetNum; k++) {
            	Sheet sheet = workbook.getSheetAt(k);
            	if(sheet != null) {
                	Row row = null;
                    String cellData = null;
                    int colnum = sheet.getRow(0).getPhysicalNumberOfCells(); //获取总列数  
                    System.out.println(colnum);
                    int rownum = sheet.getPhysicalNumberOfRows();//获取行数
//                    int rownum = sheet.getLastRowNum() + 1;
                    System.out.println(rownum);
                    //遍历每一列  
                    for (int i = 0; i<rownum; i++) {
                        row = sheet.getRow(i);
                        ArrayList<String> lst = new ArrayList<String>();
                        lst.add(sheet.getSheetName());
                        if(row !=null){
                            for (int j=0; j<colnum; j++){
//                                cellData =  row.getCell(j).getStringCellValue();
                                Cell cell = row.getCell(j);
//                                ((Object) cell).setEncoding(HSSFCell.ENCODING_UTF_16);
                                switch (cell.getCellType()) {
	                                case HSSFCell.CELL_TYPE_STRING:
	                                	cellData = cell.getStringCellValue();
	                                    break;
	                                case HSSFCell.CELL_TYPE_NUMERIC:
	                                    if (HSSFDateUtil.isCellDateFormatted(cell)) {
	                                       Date date = cell.getDateCellValue();
	                                       if (date != null) {
	                                    	   cellData = new SimpleDateFormat("yyyy-MM-dd").format(date);
	                                       } else {
	                                    	   cellData = "";
	                                       }
	                                    } else {
	                                    	cellData = new DecimalFormat("0").format(cell.getNumericCellValue());
	                                    }
	                                    break;
	                                case HSSFCell.CELL_TYPE_FORMULA:
	                                    // 导入时如果为公式生成的数据则无值
	                                    if (!cell.getStringCellValue().equals("")) {
	                                    	cellData = cell.getStringCellValue();
	                                    } else {
	                                    	cellData = cell.getNumericCellValue() + "";
	                                    }
	                                    break;
	                                case HSSFCell.CELL_TYPE_BLANK:
	                                    break;
	                                case HSSFCell.CELL_TYPE_ERROR:
	                                	cellData = "";
	                                    break;
	                                case HSSFCell.CELL_TYPE_BOOLEAN:
	                                	cellData = (cell.getBooleanCellValue() == true ? "Y"
	                                           : "N");
	                                    break;
	                                default:
	                                	cellData = "";
                                }
                                lst.add(cellData);
                            }
                            retlList.add(lst);
                        }
                    }
            	}
            }
	    } catch (IOException e) {  
	    	LOG.info("#validateExcelHeader#IOException#");  
	    } catch (InvalidFormatException e) {
	    	LOG.info("#validateExcelHeader#IOException#"); 
		}
		//2-
		
	    LOG.info("#nre2e#parseExcel#end#");
		return retlList;
	}
	
	/**
	 * 
	 */
	public static InputStream getLocalResource(String localPath) {
		// 使用类加载器的方式读
		ClassLoader classLoader = FileUtil.class.getClassLoader(); 
		// 获得流 
		InputStream is = classLoader.getResourceAsStream("resources\\Rayce HW(Default).xls") ;
		
		return is;
	}
	
	/**
	 * 获取本工程下的资源文件
	 * @return
	 */
	public static URL getLocalResourceForURL(String localPath) {
		// 使用类加载器的方式读
		ClassLoader classLoader = FileUtil.class.getClassLoader(); 
		// 获得流 
		URL url = classLoader.getResource(localPath) ;
	
		return url;
	}
	
}

5、
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;



public class ZipUtil {

	private static final Logger LOG = Logger.getLogger(ZipUtil.class);
	
	static final int BUFFER = 1024 * 10;
	static final long TOOBIG = 1024 * 1024 *1024 * 10L; // max size of unzipped data, 10GB
	static final int TOOMANY = 300000; // max number of files
	
	/**
	 * 判断是否为zip 文件
	 * @param file
	 * @return
	 */
	public static boolean isZip(String file) {
		file = file.toLowerCase(Locale.ENGLISH);
		return file.endsWith(".zip");
	}
	
	
	public static List<String> getFileList(List<String> pathList, String fileName) throws Exception{
		File file = new File(fileName);
		return getFileList(pathList, file);
	}
	
	public static void main(String[] args) {
		String pathname = "";
		List<String> list = new ArrayList<String>();
		try {
			list = getFileList(list, pathname);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println(list);
		
	}
	
	/**
	 * 获取文件列表
	 * @param pathList
	 * @param file
	 * @throws Exception
	 */
	public static List<String> getFileList(List<String> pathList, File file) throws Exception{
		if (file.exists()){
			if (!file.isDirectory()){
				String decompressPath = file.getCanonicalPath();
				File decomPressFile = new File(decompressPath);
				String absolutePath = decomPressFile.getParentFile().getAbsolutePath();
				if (decompressPath.endsWith(".zip")){
					List<String> unzip = unzip(decompressPath, absolutePath, "UTF-8");
					for (String string : unzip) {
						pathList.add(string);
					}
//					if(!file.delete()) {
//						 LOG.warn("file delete failed.");
//					}
				} else {
					pathList.add(file.getName().split(".")[0]);
				}
			} else {
				File[] listFiles = file.listFiles();
				for (int i = 0; i < listFiles.length; i++) {
					getFileList(pathList, listFiles[i]);
				}
			}
		}
		return pathList;
	}
	
	/**
	 * 解压文件, 返回文件名
	 * 
	 * @param filePath
	 *            压缩文件路径
	 * @throws Exception
	 */
	public static List<String> unzip(String filePath, String targetDir, String charset) throws IOException {
		List<String> result = new ArrayList<String>();
		File source = FileUtils.getFile(filePath);
		if (source.exists()) {
		    try (FileInputStream fis = new FileInputStream(source);
		    		ZipArchiveInputStream zaInput = new ZipArchiveInputStream(fis, "UTF-8")) {
		    	if (!FileUtils.getFile(targetDir).mkdirs())
				{
					LOG.error("Unable to create directory!");
				}
		    	ArchiveEntry archiveEntry;
 				int theNumOfEntries = 0;
		        long total = 0L;
				while ((archiveEntry = zaInput.getNextEntry()) != null) {
					if (archiveEntry.isDirectory()) {
						continue;
					}
					String entryName = archiveEntry.getName();
					File file=FileUtils.getFile(targetDir, entryName);
					if(!entryName.endsWith(".zip")){//非压缩文件
						//1-只获取天线目录，过滤其他内容
						int idx0 = entryName.indexOf("/");
						String folder = entryName.substring(0, idx0);
						if("BeamFormingUserDefined".equals(folder)) {
							String name = file.getName();
							int idx = name.indexOf(".");
							result.add(name.substring(0, idx));
							//2-获取文件名后，删除文件
//							if(!file.delete()){
//								LOG.info("failed to delete subfile.");
//							}
						}
					}
					if (!file.getParentFile().exists()) {
					    // 创建文件父目录
					    boolean isMakeDirSuccess = file.getParentFile()
					            .mkdirs();
					    if (!isMakeDirSuccess) {
					        LOG.info("make directiory error.");
					    }
					}
                    try (OutputStream os = getOutputStream(file); 
                            BufferedOutputStream bos = new BufferedOutputStream(os);) {
                    	int read = 0;
						byte[] buffer = new byte[1024 * 10];
						while (total + BUFFER < TOOBIG && (read = zaInput.read(buffer, 0, buffer.length)) != -1) {
							bos.write(buffer, 0, read);
							total += read;
						}
						bos.flush();
//						if(!entryName.endsWith(".zip")) {
//			            	if(!file.delete()){
//								System.out.println("failed to delete file.");
//								LOG.info("failed to delete subfile.");
//							}
//							if(!file.getParentFile().delete()){
//								System.out.println("failed to delete parent file.");
//								LOG.info("failed to delete parent file.");
//							}
//			            }
						theNumOfEntries++;
						if (theNumOfEntries > TOOMANY){	//解压后的总的文件数量不能超过上限
			                throw new IllegalStateException("Too many files to unzip.");
			            }
			            if (total > TOOBIG){	//解压后的总的文件大小不能超过上限
			                throw new IllegalStateException("File being unzipped is too big.");
			            }
						if(entryName.endsWith(".zip")){
							result.remove(file.getAbsolutePath());
							List<String> list = null;
							if (entryName.endsWith(".zip")){
								list = unzip(file.getAbsolutePath(),file.getParentFile().getAbsolutePath().toString(),"UTF-8");
								File subFile = FileUtils.getFile(entryName);
								if(!subFile.delete()){
									LOG.warn("subFile delete failed!");
								}
							} 
							
							for (String string : list) {
								result.add(string);
							}
							if(!file.delete()){
								LOG.warn("File delete failed!");
							}
						}
						file = null;
					} catch (Exception e)	{
						LOG.error("failed to extract directory!");
					}
				}
			} catch (IOException e) {
				LOG.error("Unable to unzip file!",e);
				throw e;
			}
		}
		return result;
	}
	
	
	public static OutputStream getOutputStream(File file) throws IOException {
        Path path = file.toPath();
        
        // Create a file with default attributes
        try {
            @SuppressWarnings("unchecked")
			FileAttribute<Set<PosixFilePermission>> attrs = (FileAttribute<Set<PosixFilePermission>>) FileAttributeUtility
                    .getDefaultFileAttribute(file);
            if (!file.exists()){//此处的if为自己加的，因不能理解报下示警告。
            	path = Files.createFile(path, attrs);
            }
        } catch (IOException e) {
            LOG.warn("Unable to create a new empty file with default attributes");
        }
        
        return Files.newOutputStream(path);
    }
	
}



二、网上资源地址
1、http://www.cnblogs.com/qingxinblog/articles/3444056.html
2、http://www.cnblogs.com/Knuth/archive/2012/05/03/2481449.html
3、http://www.cnblogs.com/opensesame/p/6064486.html
4、http://www.cnblogs.com/GarfieldEr007/p/5342822.html




三、

















